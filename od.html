
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OD (Origin-Destination) &#8212; EMMA 0.1.0 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Labeled Arrays" href="labeled_array.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="labeled_array.html" title="Labeled Arrays"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">EMMA 0.1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">OD (Origin-Destination)</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-emma.od"></span><div class="toctree-wrapper compound">
</div>
<div class="section" id="od-origin-destination">
<h1>OD (Origin-Destination)<a class="headerlink" href="#od-origin-destination" title="Permalink to this headline">¶</a></h1>
<p>Origin-Destination data are essential to many travel analyses.
Emma relies heavily on OD data to analyze accessibility, trip distribution,
system productivity, etc.</p>
<p>This module provides classes and functions that facilitate the creation,
storage, and retrieval of OD matrices as well as methods for developing
and executing functions using multiple matrices. Matrix data may be stored
in the h5 file format, for efficient on-disk processing.</p>
<p>Module objectives:
- efficient I/O between tabular OD data and matrices.
- efficient replication of matrix structures and/or values for OD processing.
- consistent processing idioms for vectorized formula applications.</p>
<p><strong>Classes and functions</strong>
- <cite>Skim</cite>: stores OD data as a specialized labeled array. Skims always have</p>
<blockquote>
<div><p>congruent <em>i</em> (origins) and <em>j</em> (destinations) dimensions. Skim is a child
class of <cite>LbArray</cite>, inheriting (or in a few cases overloading) its attributes
and methods while adding a handful of distinct attributes and methods to
ensure preservation of the <em>i</em> and <em>j</em> dimensions.</p>
</div></blockquote>
<ul class="simple">
<li><p>The <cite>loadOD_…</cite> family of functions supports reading origin-destination
data from a long table into a Skim object. The skim object must be
already initialized. Supported formats include: csv (most performant),
ESRI geodatabase, DBF, or Excel.</p></li>
<li><p><cite>maxInteractions</cite>/<cite>weightedInteractions</cite> are functions that consume origin-
end and desetination-end activity data in a pandas DataFrame to generate
a Skim reflecting trip-making potential among OD pairs.</p></li>
<li><p><cite>summarizeAccess</cite> uses origin-end OR destination-end activty data in a
pandas DataFrame and one or more Decay objects (see the <cite>decay</cite> module)
to generate access scores to/from each zone.</p></li>
<li><p><cite>distribute</cite> provides a simple function for balancing a trip table based
on zone-levl productions and attractions. Currently the function only works
for a simple 2d matrix.</p></li>
<li><p><cite>openSkim_HDF</cite> loads a skim object from an on-disk array (H5 file). Skims
constructed with H5 file specs are intialized on-disk and parameters for
reloading the Skim object from the H5 file are stored as attributes.</p></li>
<li><p><cite>csrVApply</cite> is an early foray into supporting sparse matrix applications,
but it remains untested.</p></li>
</ul>
<div class="section" id="skim">
<h2>Skim<a class="headerlink" href="#skim" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="emma.od.Skim">
<em class="property">class </em><code class="sig-prename descclassname">emma.od.</code><code class="sig-name descname">Skim</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">zones</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">axes_k</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">desc</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">hdf_store</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">node_path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">atom</span><span class="o">=</span><span class="default_value">Float64Atom(shape=(), dflt=0.0)</span></em>, <em class="sig-param"><span class="n">driver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.Skim" title="Permalink to this definition">¶</a></dt>
<dd><p>The Skim class stores origin-destination data in a labeled array.
Attributes record dimesional details (LbAxis parameters)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zones</strong> (<em>array like 1d</em>) – An object containing zone names and indices for reference when
indexing/slicing the skim matrix. The zones argument defines the
two key axes of the labeled array (the <em>i</em> and <em>j</em> dimensions)
as “From” and “To”. Multi-level indices (pd.MultiIndex, e.g.)
are supported.</p></li>
<li><p><strong>data</strong> (<em>array like</em><em> or </em><em>numpy array constructor</em>) – The ndarray that contains the data in the skim. This can be an on-disk
pytables array or a numpy array or numpy array constructor.</p></li>
<li><p><strong>axes_k</strong> (<em>[</em><a class="reference internal" href="labeled_array.html#emma.labeled_array.LbAxis" title="emma.labeled_array.LbAxis"><em>LbAxis</em></a><em>,</em><em>..</em><em>]</em><em>, </em><em>default=None</em>) – One or more LbAxis objects that describe the <em>k-plus</em> dimensions
of the array (those besides the “From” and “To” dimensions defined
by <cite>zones</cite>).</p></li>
<li><p><strong>desc</strong> (<em>String</em>) – A description of the contents of the skim.</p></li>
<li><p><strong>hdf_store</strong> (<em>String</em><em>, </em><em>default=None</em>) – If using an on-disk array to store the skim and initialize data, give
the path to the H5 file. If <cite>data</cite> is an existing pytables array and
<cite>hdf_store</cite> is provided, the data will be replicated in the new node.</p></li>
<li><p><strong>node_path</strong> (<em>String</em><em>, </em><em>default=None</em>) – The node path in the H5 hierarchy within the <cite>hdf_store</cite>.</p></li>
<li><p><strong>name</strong> (<em>String</em><em>, </em><em>default=None</em>) – The name of the new node to be created.</p></li>
<li><p><strong>atom</strong> (<em>tb.Atom</em>) – The atom (data type) of the new array.</p></li>
<li><p><strong>driver</strong> (<em>String</em><em>, </em><em>default=None</em>) – The HDF connection driver.</p></li>
<li><p><strong>overwrite</strong> (<em>Boolean</em><em>, </em><em>default=False</em>) – If True, the existing node at <em>`node_path`/`name`</em> (if any) will
be discarded and replaced with the new node.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments for initializing the data. Kwargs vary by
the data initialization method provided.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="emma.od.Skim.nzones">
<code class="sig-name descname">nzones</code><a class="headerlink" href="#emma.od.Skim.nzones" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of zones in the matrix (the length of each axis)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>Integer</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="emma.od.Skim.axes">
<code class="sig-name descname">axes</code><a class="headerlink" href="#emma.od.Skim.axes" title="Permalink to this definition">¶</a></dt>
<dd><p>The axes defining dimensions and labels.  The <cite>zones</cite> parameter
is used to creat the “From” and “To” dimensions, and these are
combined with <cite>axes_k</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>[<a class="reference internal" href="labeled_array.html#emma.labeled_array.LbAxis" title="emma.labeled_array.LbAxis">LbAxis</a>,..]</p>
</dd>
</dl>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">LbArray</span></code></p>
</div>
<dl class="py method">
<dt id="emma.od.Skim.cast">
<code class="sig-name descname">cast</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">new_axes</span></em>, <em class="sig-param"><span class="n">squeeze</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">hdf_store</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">node_path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">atom</span><span class="o">=</span><span class="default_value">Float64Atom(shape=(), dflt=0.0)</span></em>, <em class="sig-param"><span class="n">driver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">desc</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.Skim.cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of this skim cast along additional axes_k dimensions.</p>
<dl class="simple">
<dt>Overrides the LbArray implementation of <cite>cast</cite> as follows:</dt><dd><ul class="simple">
<li><p>Data are always copied.</p></li>
<li><p>No existing dimensions can be dropped.</p></li>
<li><p>Selection criteria (keyword arguments) are ignored for the skim’s
<cite>From</cite> and <cite>To</cite> axes to ensure consistency in the i and j
dimensions.</p></li>
</ul>
</dd>
</dl>
<p>To cast skims into labeled arrays, consider the <cite>impress</cite> method.
To fill with alternative data before casting, consider the <cite>stamp</cite>
method, followed by <cite>cast</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_axes</strong> (<a class="reference internal" href="labeled_array.html#emma.labeled_array.LbAxis" title="emma.labeled_array.LbAxis"><em>LbAxis</em></a><em> or </em><em>[</em><a class="reference internal" href="labeled_array.html#emma.labeled_array.LbAxis" title="emma.labeled_array.LbAxis"><em>LbAxis</em></a><em>,</em><em>..</em><em>]</em>) – Labeled axis object(s) defining the dimensions into which an
impression of this array will be stamped.</p></li>
<li><p><strong>squeeze</strong> (<em>Boolean</em><em>, </em><em>default=False</em>) – If True, axes that have only a single label will be dropped and
the dimensionality of the array selection reduced. If False,
the returned array has the same number of dimensions as the
source array.</p></li>
<li><p><strong>hdf_store</strong> (<em>String</em><em>, </em><em>default=None</em>) – If using an on-disk array to store the filled impression, give
the path to the H5 file.</p></li>
<li><p><strong>node_path</strong> (<em>String</em><em>, </em><em>default=None</em>) – The node path in the H5 hierarchy within the <cite>hdf_store</cite>.</p></li>
<li><p><strong>name</strong> (<em>String</em><em>, </em><em>default=None</em>) – The name of the new node to be created.</p></li>
<li><p><strong>atom</strong> (<em>tb.Atom</em>) – The atom (data type) of the new array.</p></li>
<li><p><strong>driver</strong> (<em>String</em><em>, </em><em>default=None</em>) – The HDF connection driver.</p></li>
<li><p><strong>overwrite</strong> (<em>Boolean</em><em>, </em><em>default=False</em>) – If True, the existing node at <em>`node_path`/`name`</em> (if any) will
be discarded and replaced with the new node.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments specifying a selection from this array to
cast into new dimensions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>casted</strong> – If <cite>copy_data</cite> is True, an LbArray is returned with data
from the original array replicated in new dimensions.
Otherwise, a new impression is made that can be filled with
fresh data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="labeled_array.html#emma.labeled_array.Impression" title="emma.labeled_array.Impression">Impression</a> or <a class="reference internal" href="labeled_array.html#emma.labeled_array.LbArray" title="emma.labeled_array.LbArray">LbArray</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emma.od.Skim.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hdf_store</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">node_path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">atom</span><span class="o">=</span><span class="default_value">Float64Atom(shape=(), dflt=0.0)</span></em>, <em class="sig-param"><span class="n">driver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.Skim.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this skim’s contents to a new labeled array with the
same axis names and labels. Optional arguments allow HDF
storage in the specified file and node (overwriting existing
content if directed)</p>
<p>If args are provided, they focus on copying the data into a new
h5 data store node. Otherwise an in-memory copy (numpy) as returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hdf_store</strong> (<em>String</em><em>, </em><em>default=None</em>) – If using an on-disk array to store the filled impression, give
the path to the H5 file.</p></li>
<li><p><strong>node_path</strong> (<em>String</em><em>, </em><em>default=None</em>) – The node path in the H5 hierarchy within the <cite>hdf_store</cite>.</p></li>
<li><p><strong>name</strong> (<em>String</em><em>, </em><em>default=None</em>) – The name of the new node to be created.</p></li>
<li><p><strong>atom</strong> (<em>tb.Atom</em>) – The atom (data type) of the new array.</p></li>
<li><p><strong>driver</strong> (<em>String</em><em>, </em><em>default=None</em>) – The HDF connection driver.</p></li>
<li><p><strong>overwrite</strong> (<em>Boolean</em><em>, </em><em>default=False</em>) – If casting to an on-disk array at an existing node, the
node will be replaced with new data if overwrite=True.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emma.od.Skim.fetch">
<code class="sig-name descname">fetch</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">squeeze</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.Skim.fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve values from the Skim based on axis names and labels.</p>
<p>This is essentially like calling <cite>take</cite> except the i and j
dimensions always remain intact and a new Skim is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>squeeze</strong> (<em>Boolean</em><em>, </em><em>default=False</em>) – If True, axes that have only a single label will be dropped and
the dimensionality of the array selection reduced. If False,
the returned array has the same number of dimensions as the
source array.</p></li>
<li><p><strong>kwargs</strong> – kwargs can be passed with keys corresponding to axis names and
values corresponding to labels in the given axis. The “From”
and “To” axis (i and j dimensions) cannot be used when fetching -
instead use <cite>take</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>filtered_skim</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#emma.od.Skim" title="emma.od.Skim">Skim</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">LbArray.take()</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="emma.od.Skim.stamp">
<code class="sig-name descname">stamp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fill_with</span></em>, <em class="sig-param"><span class="n">drop</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">squeeze</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">hdf_store</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">node_path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">atom</span><span class="o">=</span><span class="default_value">Float64Atom(shape=(), dflt=0.0)</span></em>, <em class="sig-param"><span class="n">driver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">constr_kwargs</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">desc</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.Skim.stamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new skim based on this skim. The new skim retains
axis details (shape and labels)reflecting axis criteria passed as
keyword arguments. The skim must be filled with data. To create
an unfilled impression, use the <cite>impress</cite> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fill_with</strong> (<em>array-like</em><em>, </em><em>scalar</em><em>, or </em><em>constructor</em>) – The data to fill this impression with.</p></li>
<li><p><strong>drop</strong> (<em>[</em><em>LBAxis</em><em> or </em><em>String</em><em>,</em><em>..</em><em>]</em><em>, </em><em>default=None</em>) – Specify any axes to be excluded from the new impression using the
axis object or name. Axes used for keyword selection cannot be
dropped.</p></li>
<li><p><strong>squeeze</strong> (<em>Boolean</em><em>, </em><em>default=False</em>) – If True, axes that have only a single label will be dropped and
the dimensionality of the new impression reduced. If False,
the returned impression has the same number of dimensions as the
source.</p></li>
<li><p><strong>hdf_store</strong> (<em>String</em><em>, </em><em>default=None</em>) – If using an on-disk array to store the filled impression, give
the path to the H5 file.</p></li>
<li><p><strong>node_path</strong> (<em>String</em><em>, </em><em>default=None</em>) – The node path in the H5 hierarchy within the <cite>hdf_store</cite>.</p></li>
<li><p><strong>name</strong> (<em>String</em><em>, </em><em>default=None</em>) – The name of the new node to be created.</p></li>
<li><p><strong>atom</strong> (<em>tb.Atom</em>) – The atom (data type) of the new array.</p></li>
<li><p><strong>driver</strong> (<em>String</em><em>, </em><em>default=None</em>) – The HDF connection driver.</p></li>
<li><p><strong>overwrite</strong> (<em>Boolean</em><em>, </em><em>default=False</em>) – If True, the existing node at <em>`node_path`/`name`</em> (if any) will
be discarded and replaced with the new node.</p></li>
<li><p><strong>= {}</strong> (<em>constr_kwargs</em>) – If filling the impression with a constructor (np.ones, e.g.), pass
any constructor function kwargs in a dictionary.</p></li>
<li><p><strong>kwargs</strong> – kwargs can be passed with keys corresponding to axis names and
values corresponding to labels in the given axis. For example
<cite>a.take(origins=[1,2,3], destinations=[4,5,6])</cite> or
<cite>a.take(**{“origins”:[1,2,3], “destination”:[4,5,6]})</cite>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Impression.impress()</span></code></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="emma.od.csrVApply">
<code class="sig-prename descclassname">emma.od.</code><code class="sig-name descname">csrVApply</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vfunc</span></em>, <em class="sig-param"><span class="n">csr_mat</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.csrVApply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a vectorized function to values in a sparse (csr) matrix.
It also works for a csc matrix (?right? seems like it should).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vfunc</strong> (<em>callable</em>) – A vectorized function (see <cite>numpy.vectorize</cite>)</p></li>
<li><p><strong>csr_mat</strong> (<em>scipy.sparse.csr.csr_matrix</em>) – A compressed sparse row (csr) matrix</p></li>
<li><p><strong>*args</strong> (ordered arguments for <cite>vfunc</cite>) – </p></li>
<li><p><strong>**kwargs</strong> (key-word args accepted by <cite>vfunc</cite>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emma.od.distribute">
<code class="sig-prename descclassname">emma.od.</code><code class="sig-name descname">distribute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">decay_skim</span></em>, <em class="sig-param"><span class="n">prods_df</span></em>, <em class="sig-param"><span class="n">prods_col</span></em>, <em class="sig-param"><span class="n">attrs_df</span></em>, <em class="sig-param"><span class="n">attrs_col</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">prods_id</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">prods_index</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">attrs_id</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">attrs_index</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">hdf_store</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">node_path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">driver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">converges_at</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">max_iters</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="n">tolerance</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">report_convergence</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.distribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and solve an iterative proportional fitting (IPF) problem, seeded
based on weights in the decay skim, trip productions in a data frame, and
trip attractions in a data frame.</p>
<dl class="simple">
<dt>decay_skim: Skim</dt><dd><p>The skim object containing decay factors for each OD pair.</p>
</dd>
<dt>prods_df: DataFrame</dt><dd><p>The data frame containing estimates of trip productions.</p>
</dd>
<dt>prods_col: String</dt><dd><p>The name of the field in <cite>prods_df</cite> that contains trip production
estimates.</p>
</dd>
<dt>attrs_df: DataFrame</dt><dd><p>The data frame containing estimates of trip productions.</p>
</dd>
<dt>attrs_col: String</dt><dd><p>The name of the field in <cite>attrs_df</cite> that contains trip attraction
estimates.</p>
</dd>
<dt>level: String or Int, default=None</dt><dd><p>If the decay skim’s <cite>zones</cite> attribute is a MultiIndex, a
level name may be specified on which to reindex the input data
frame.</p>
</dd>
<dt>prods_id: String, default=</dt><dd><p>A column in the productions data frame used to reindex the data frame
to match the indexing of the decay skim.</p>
</dd>
<dt>prods_index: Boolean, default=False</dt><dd><p>If true, the destinations data frame’s index will be the used when
reindexing to match the indexing of the decay skim.</p>
</dd>
<dt>attrs_id: String, default=None</dt><dd><p>A column in the attractions data frame used to reindex the data frame
to match the indexing of the decay skim.</p>
</dd>
<dt>attrs_index: Boolean, default=False</dt><dd><p>If true, the destinations data frame’s index will be the used when
reindexing to match the indexing of the decay skim.</p>
</dd>
<dt>hdf_store: String, default=None</dt><dd><p>If creating a new on-disk array to store the resulting array, give
the path to the H5 file.</p>
</dd>
<dt>node_path: String, default=None</dt><dd><p>The node path in the H5 hierarchy within the <cite>hdf_store</cite>.</p>
</dd>
<dt>name: String, default=None</dt><dd><p>The name of the new node to be created.</p>
</dd>
<dt>driver: String, default=None</dt><dd><p>The HDF connection driver.</p>
</dd>
<dt>overwrite: Boolean, default=False</dt><dd><p>If True, the existing node at <em>`node_path`/`name`</em> (if any) will
be discarded and replaced with the new node.</p>
</dd>
<dt>converges_at: Float</dt><dd><p>Specificies a convergence value. If the percentage error
between seed marginals and production and attraction targets
is less than or equal to this value, the IPF process exits,
returning an adequately fitted matrix. Default is 1e-5</p>
</dd>
<dt>max_iters: Int</dt><dd><p>Maximum number of iterations allowed. The IPF process exits
after this number of iterations even if convergence has not been
achieved. Default is 500.</p>
</dd>
<dt>tolerance: Float</dt><dd><p>The IPF process exits if the difference between the convergence
variables of two consecutive iterations is below this value.
If there is minimal difference between two iterations, the process
is unlikely to acheive substantially stronger convergence through
additional interations. Default is 1e-8.</p>
</dd>
<dt>report_convergence: Boolean</dt><dd><p>If False (default), only the rebalanced matrix is returned. If
True, the details of the IPF are returned as a tuple.</p>
</dd>
<dt>report_convergence: Boolean</dt><dd><p>If False (default), only the rebalanced matrix is returned. If
True, the details of the IPF are returned as a tuple.</p>
</dd>
<dt>kwargs:</dt><dd><p>Keyword arguments defining slices of the decay skim to take for
seeding distribution.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>trip_table</strong> (<em>Skim</em>) – A balanced matrix where marginals match (or approximate) the
production and attraction totals given.</p></li>
<li><p><strong>number_of_iterations</strong> (<em>Int</em>) – If <cite>report_convergence</cite> is True, the second value returned is the
number of iterations completed by the IPF process</p></li>
<li><p><strong>convergence</strong> (<em>Boolean</em>) – If <cite>report_convergence</cite> is True, the third value returned is a
boolean flag indicating whether convergence was acheived.</p></li>
<li><p><strong>narrowing</strong> (<em>Boolean</em>) – If <cite>report_convergence</cite> is True, the fourth value returned is a
boolean flag indicating whether convergence was narrowing in the
final iteration. If False, the IPF has exited due to minimal
improvement in convergence in two consecutve runs.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emma.od.loadOD_csv">
<code class="sig-prename descclassname">emma.od.</code><code class="sig-name descname">loadOD_csv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">skim</span></em>, <em class="sig-param"><span class="n">source_file</span></em>, <em class="sig-param"><span class="n">o_field</span></em>, <em class="sig-param"><span class="n">d_field</span></em>, <em class="sig-param"><span class="n">val_fields_dict</span></em>, <em class="sig-param"><span class="n">chunk_rows</span><span class="o">=</span><span class="default_value">500000</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.loadOD_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Import OD data from a long table (csv) into a labeled array
(pytables array) format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>skim</strong> (<a class="reference internal" href="#emma.od.Skim" title="emma.od.Skim"><em>Skim</em></a>) – The skim object to which OD values will be assigned from the long
table. Origin/desination indexing is handled by the skim object’s
<cite>zones</cite> attribute.</p></li>
<li><p><strong>source_file</strong> (<em>String</em>) – The csv file containing long-form OD data</p></li>
<li><p><strong>o_field</strong> (<em>String</em><em> or </em><em>Int</em>) – The field name or index that identifies the origin zone in each
OD row.</p></li>
<li><p><strong>d_field</strong> (<em>String</em><em> or </em><em>Int</em>) – The field name or index that identifies the destination zone in each
OD row.</p></li>
<li><p><strong>val_fields_dict</strong> (<em>{String: {String: String}</em><em>, </em><em>..}</em>) – A dictionary with keys corresponding to column names in <cite>source_file</cite>
and values corresponding to dimension/label criteria in the <cite>skim</cite>
(<em>{“AM_HBW_Trips”: {“Period”: “AM”, “Purpose”: “HBW”}</em>, e.g.).</p></li>
<li><p><strong>chunk_rows</strong> (<em>Int</em><em>, </em><em>default=500000</em>) – If importing a large table, chunking rows is recommended to avoid
memory errors.</p></li>
<li><p><strong>level</strong> (<em>String</em><em>, </em><em>default=None</em>) – If the skim’s <cite>zones</cite> attribute is a multi-index, provide the level
name within the index to which values in <cite>o_field</cite> and <cite>d_field</cite>
correspond.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments for pandas read_csv function.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emma.od.loadOD_dbf">
<code class="sig-prename descclassname">emma.od.</code><code class="sig-name descname">loadOD_dbf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">skim</span></em>, <em class="sig-param"><span class="n">source_file</span></em>, <em class="sig-param"><span class="n">o_field</span></em>, <em class="sig-param"><span class="n">d_field</span></em>, <em class="sig-param"><span class="n">val_fields_dict</span></em>, <em class="sig-param"><span class="n">chunk_rows</span><span class="o">=</span><span class="default_value">500000</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.loadOD_dbf" title="Permalink to this definition">¶</a></dt>
<dd><p>Import OD data from a long table (dbf) into a labeled array
(pytables array) format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>skim</strong> (<a class="reference internal" href="#emma.od.Skim" title="emma.od.Skim"><em>Skim</em></a>) – The skim object to which OD values will be assigned from the long
table. Origin/desination indexing is handled by the skim object’s
<cite>zones</cite> attribute.</p></li>
<li><p><strong>source_file</strong> (<em>String</em>) – The dbf file containing long-form OD data</p></li>
<li><p><strong>o_field</strong> (<em>String</em><em> or </em><em>Int</em>) – The field name or index that identifies the origin zone in each
OD row.</p></li>
<li><p><strong>d_field</strong> (<em>String</em><em> or </em><em>Int</em>) – The field name or index that identifies the destination zone in each
OD row.</p></li>
<li><p><strong>val_fields_dict</strong> (<em>{String: String</em><em>, </em><em>..}</em>) – A dictionary with keys corresponding to column names in <cite>source_file</cite>
and values corresponding to dimension/label criteria in the <cite>skim</cite>
(<em>{“AM_HBW_Trips”: {“Period”: “AM”, “Purpose”: “HBW”}</em>, e.g.).</p></li>
<li><p><strong>chunk_rows</strong> (<em>Int</em><em>, </em><em>default=500000</em>) – If importing a large table, chunking rows is recommended to avoid
memory errors.</p></li>
<li><p><strong>level</strong> (<em>String</em><em>, </em><em>default=None</em>) – If the skim’s <cite>zones</cite> attribute is a multi-index, provide the level
name within the index to which values in <cite>o_field</cite> and <cite>d_field</cite>
correspond.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emma.od.loadOD_gdb">
<code class="sig-prename descclassname">emma.od.</code><code class="sig-name descname">loadOD_gdb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">skim</span></em>, <em class="sig-param"><span class="n">source_file</span></em>, <em class="sig-param"><span class="n">layer_name</span></em>, <em class="sig-param"><span class="n">o_field</span></em>, <em class="sig-param"><span class="n">d_field</span></em>, <em class="sig-param"><span class="n">val_fields_dict</span></em>, <em class="sig-param"><span class="n">chunk_rows</span><span class="o">=</span><span class="default_value">500000</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.loadOD_gdb" title="Permalink to this definition">¶</a></dt>
<dd><p>Import OD data from a long table (dbf) into a labeled array
(pytables array) format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>skim</strong> (<a class="reference internal" href="#emma.od.Skim" title="emma.od.Skim"><em>Skim</em></a>) – The skim object to which OD values will be assigned from the long
table. Origin/desination indexing is handled by the skim object’s
<cite>zones</cite> attribute.</p></li>
<li><p><strong>source_file</strong> (<em>String</em>) – The geodatabase containing long-form OD data.</p></li>
<li><p><strong>layer_name</strong> (<em>String</em>) – The feature class or table in <cite>source_file</cite> to import.</p></li>
<li><p><strong>o_field</strong> (<em>String</em><em> or </em><em>Int</em>) – The field name or index that identifies the origin zone in each
OD row.</p></li>
<li><p><strong>d_field</strong> (<em>String</em><em> or </em><em>Int</em>) – The field name or index that identifies the destination zone in each
OD row.</p></li>
<li><p><strong>val_fields_dict</strong> (<em>{String: String</em><em>, </em><em>..}</em>) – A dictionary with keys corresponding to column names in <cite>source_file</cite>
and values corresponding to dimension/label criteria in the <cite>skim</cite>
(<em>{“AM_HBW_Trips”: {“Period”: “AM”, “Purpose”: “HBW”}</em>, e.g.).</p></li>
<li><p><strong>chunk_rows</strong> (<em>Int</em><em>, </em><em>default=500000</em>) – If importing a large table, chunking rows is recommended to avoid
memory errors.</p></li>
<li><p><strong>level</strong> (<em>String</em><em>, </em><em>default=None</em>) – If the skim’s <cite>zones</cite> attribute is a multi-index, provide the level
name within the index to which values in <cite>o_field</cite> and <cite>d_field</cite>
correspond.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emma.od.loadOD_excel">
<code class="sig-prename descclassname">emma.od.</code><code class="sig-name descname">loadOD_excel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">skim</span></em>, <em class="sig-param"><span class="n">source_file</span></em>, <em class="sig-param"><span class="n">sheet_name</span></em>, <em class="sig-param"><span class="n">o_field</span></em>, <em class="sig-param"><span class="n">d_field</span></em>, <em class="sig-param"><span class="n">val_fields_dict</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.loadOD_excel" title="Permalink to this definition">¶</a></dt>
<dd><p>Import OD data from a long table (excel) into a labeled array
(pytables array) format. No chunking is done with excel files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>skim</strong> (<a class="reference internal" href="#emma.od.Skim" title="emma.od.Skim"><em>Skim</em></a>) – The skim object to which OD values will be assigned from the long
table. Origin/desination indexing is handled by the skim object’s
<cite>zones</cite> attribute.</p></li>
<li><p><strong>source_file</strong> (<em>xlrd_io</em>) – The excel file containing long-form OD data.</p></li>
<li><p><strong>o_field</strong> (<em>String</em><em> or </em><em>Int</em>) – The field name or index that identifies the origin zone in each
OD row.</p></li>
<li><p><strong>d_field</strong> (<em>String</em><em> or </em><em>Int</em>) – The field name or index that identifies the destination zone in each
OD row.</p></li>
<li><p><strong>val_fields_dict</strong> (<em>{String: String</em><em>, </em><em>..}</em>) – A dictionary with keys corresponding to column names in <cite>source_file</cite>
and values corresponding to dimension/label criteria in the <cite>skim</cite>
(<em>{“AM_HBW_Trips”: {“Period”: “AM”, “Purpose”: “HBW”}</em>, e.g.).</p></li>
<li><p><strong>level</strong> (<em>String</em><em>, </em><em>default=None</em>) – If the skim’s <cite>zones</cite> attribute is a multi-index, provide the level
name within the index to which values in <cite>o_field</cite> and <cite>d_field</cite>
correspond.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emma.od.maxInteractions">
<code class="sig-prename descclassname">emma.od.</code><code class="sig-name descname">maxInteractions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">zones_df</span></em>, <em class="sig-param"><span class="n">o_values</span></em>, <em class="sig-param"><span class="n">d_values</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.maxInteractions" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses activity values in a zones data frame to evaluate the maximum
“interaction” potential between each zone in a hypothetical, frictionless
world.</p>
<p>Interaction describes probable trip-making potential. Maximum interactions
analyses frame theoretical trip-making opportunities to support network
effectiveness analyses and/or seed trip distribution processes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zones_df</strong> (<em>Pandas data frame</em>) – The data frame containing activity informaiton. Zone labels are not
required, but consistent indexing of the data frame with any related
skim objects to be used in downstream procedures is essential.</p></li>
<li><p><strong>o_values</strong> (<em>String</em>) – The column in <cite>zones_df</cite> with origin-end activity data (households,
trip productions, e.g.)</p></li>
<li><p><strong>d_values</strong> (<em>String</em>) – The column in <cite>zones_df</cite> with destination-end activity data (jobs,
trip attractions, e.g.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>maxInteractions</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2d array</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#emma.od.weightedInteractions" title="emma.od.weightedInteractions"><code class="xref py py-func docutils literal notranslate"><span class="pre">weightedInteractions()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="emma.od.openSkim_HDF">
<code class="sig-prename descclassname">emma.od.</code><code class="sig-name descname">openSkim_HDF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hdf_store</span></em>, <em class="sig-param"><span class="n">node_path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.openSkim_HDF" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a Skim object from a node in an hdf file.</p>
<p>The hdf file must have the expected attributes for
reconstructing a Skim object (these are stored when a
skim references an hdf node as its <cite>data</cite> attribute).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hdf_store</strong> (<em>String</em>) – The path to the H5 file.</p></li>
<li><p><strong>node_path</strong> (<em>String</em><em>, </em><em>default=None</em>) – The path to the node in the H5 file.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong> – A skim object built around the on-disk array at the hdf node.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#emma.od.Skim" title="emma.od.Skim">Skim</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emma.od.summarizeAccess">
<code class="sig-prename descclassname">emma.od.</code><code class="sig-name descname">summarizeAccess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">zones_df</span></em>, <em class="sig-param"><span class="n">activity_col</span></em>, <em class="sig-param"><span class="n">decay_skim</span></em>, <em class="sig-param"><span class="n">key_level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">access_to_dests</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.summarizeAccess" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses activity values in a zones data frame and a decay skim to
summarize the number of <em>destination-end</em> activities reachable from
each origin zone (access_to_dests=True) or the number of <em>origin-end</em>
activities that can reach each destination zone (access_to_dests=False).</p>
<dl class="simple">
<dt>zones_df: Pandas data frame</dt><dd><p>The index is used to match zone names in the data frame to the
<cite>zones</cite> attribute of the skim.</p>
</dd>
<dt>activity_col: string or [string,…]</dt><dd><p>The column(s) in <cite>zones_df</cite> with activity data (jobs, households, e.g.)</p>
</dd>
<dt>decay_skim: Skim</dt><dd><p>The skim object containing decay factors for each OD pair.</p>
</dd>
<dt>Key_level: String or Int, default=None</dt><dd><p>If the decay skim’s <cite>zones</cite> attribute is a MultiIndex, a key level may
be specified on which to reindex <cite>zones_df</cite>.</p>
</dd>
<dt>access_to_dests: Boolean</dt><dd><p>If True (default), the function returns the number of destination
activities reachable <em>from each zone of origin</em> (row sums). If False,
the fucntion returns the number of origin activities that can reach
<em>each zone of destination</em> (column sums).</p>
</dd>
<dt>kwargs:</dt><dd><p>Keyword arguments that specify the axis dimensions and labels from
which to fetch OD decay values from the <cite>decay_skim</cite>.
For example: <cite>impedances=’CongTime’, period=[‘am’, ‘pm’]</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emma.od.weightedInteractions">
<code class="sig-prename descclassname">emma.od.</code><code class="sig-name descname">weightedInteractions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">decay_skim</span></em>, <em class="sig-param"><span class="n">origins_df</span></em>, <em class="sig-param"><span class="n">origins_col</span></em>, <em class="sig-param"><span class="n">dests_df</span></em>, <em class="sig-param"><span class="n">dests_col</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">origins_id</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">origins_index</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">dests_id</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dests_index</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">weighting_factor</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">hdf_store</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">node_path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">driver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emma.od.weightedInteractions" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and solve an iterative proportional fitting problem, seeded based
on weights in the decay skim, trip productions in a data frame, and
trip attractions in a data frame.</p>
<dl class="simple">
<dt>decay_skim: Skim</dt><dd><p>The skim object containing decay factors for each OD pair.</p>
</dd>
<dt>origins_df: DataFrame</dt><dd><p>The data frame containing estimates of origin-end activity.</p>
</dd>
<dt>origins_col: String</dt><dd><p>The name of the field in <cite>origins_df</cite> that contains origin activity
estimates</p>
</dd>
<dt>dests_df: DataFrame</dt><dd><p>The data frame containing estimates of destination-end activity.</p>
</dd>
<dt>dests_col: String</dt><dd><p>The name of the field in <cite>dests_df</cite> that contains destination activity
estimates</p>
</dd>
<dt>level: String or Int, default=None</dt><dd><p>If the reference skim’s <cite>zones</cite> attribute is a MultiIndex, a
level name may be specified on which to reindex the input data
frames.</p>
</dd>
<dt>origins_id: String, default=None</dt><dd><p>A column in the origins data frame used to reindex the data frame
to match the indexing of the decay skim.</p>
</dd>
<dt>prods_index: Boolean, default=False</dt><dd><p>If true, the origins data frame’s index will be the used when
reindexing to match the indexing of the decay skim.</p>
</dd>
<dt>dests_id: String, default=None</dt><dd><p>A column in the destinations data frame used to reindex the data frame
to match the indexing of the decay skim.</p>
</dd>
<dt>dests_index: Boolean, default=False</dt><dd><p>If true, the destinations data frame’s index will be the used when
reindexing to match the indexing of the decay skim.</p>
</dd>
<dt>weighting_factor: Numeric</dt><dd><p>A scalar value by which weighted interaction scores are multiplied
(to approximate total trip counts when seeding a trip distibution
matrix, e.g.)</p>
</dd>
<dt>hdf_store: String, default=None</dt><dd><p>If creating a new on-disk array to store the resulting array, give
the path to the H5 file.</p>
</dd>
<dt>node_path: String, default=None</dt><dd><p>The node path in the H5 hierarchy within the <cite>hdf_store</cite>.</p>
</dd>
<dt>name: String, default=None</dt><dd><p>The name of the new node to be created.</p>
</dd>
<dt>driver: String, default=None</dt><dd><p>The HDF connection driver.</p>
</dd>
<dt>overwrite: Boolean, default=False</dt><dd><p>If True, the existing node at <em>`node_path`/`name`</em> (if any) will
be discarded and replaced with the new node.</p>
</dd>
<dt>kwargs:</dt><dd><p>Keyword arguments defining slices of the decay skim to take for
seeding distribution.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>weighted_interactions</strong> – A skim object with values reflecting proportional trip-making
propensities among OD pairs.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#emma.od.Skim" title="emma.od.Skim">Skim</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#emma.od.maxInteractions" title="emma.od.maxInteractions"><code class="xref py py-func docutils literal notranslate"><span class="pre">maxInteractions()</span></code></a>, <a class="reference internal" href="#emma.od.distribute" title="emma.od.distribute"><code class="xref py py-func docutils literal notranslate"><span class="pre">distribute()</span></code></a></p>
</div>
</dd></dl>

<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="index.html">Table of Contents</a></h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="README.html">Emma</a></li>
<li class="toctree-l1"><a class="reference internal" href="decay.html">Decay</a></li>
<li class="toctree-l1"><a class="reference internal" href="io.html">I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="ipf.html">IPF</a></li>
<li class="toctree-l1"><a class="reference internal" href="labeled_array.html">Labeled Arrays</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">OD (Origin-Destination)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#skim">Skim</a></li>
<li class="toctree-l2"><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="labeled_array.html"
                        title="previous chapter">Labeled Arrays</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/od.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="labeled_array.html" title="Labeled Arrays"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">EMMA 0.1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">OD (Origin-Destination)</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Renaissance Planning.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.1.
    </div>
  </body>
</html>